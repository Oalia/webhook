# @app.route('/webhook', methods=['POST'])
# def webhook():
#     if request.method == 'POST':
#         print("hello webhook")
#         webhook_msg = json.loads(request.data)
#         # ticker = webhook_msg['ticker']
#         # time = webhook_msg['time']
#         # volume = webhook_msg['bar']['volume']
#         print(webhook_msg)
#         return 'success', 200
#     else:
#         abort(400)


def strategy_minus_step_one_buy(sym,dir,size,type):
    strategy_name = "minus_step_one_buy"
    if type == "big":
        current_trade = DB.get_current_trade(sym, strategy_name)
        if current_trade != None: #if a trade is open
            if current_trade['is_trade_closed'] == 0: 
                cur_dir = current_trade['dir']
                if cur_dir != dir: # if trade direction has changed.
                    print("TRYING TO CLOSE HALF CYCLE:\n")
                    TD.close_half_cycle(sym, dir, strategy_name)
                else:
                    print("ABOUT TO STEP FORWARD: WEAR YOUR SEATBELTS\n")
                    DB.update_step(sym, dir)
            elif current_trade['is_trade_closed'] == 1: 
                if dir == "DN":
                    print("NO OPEN TRADES ON KNOWN SYMBOL. ENTERING.\n")
                    TD.enter_half_cycle(sym, dir, size, strategy_name)
        else:
            if dir == "DN":
                print("NO CURRENT TRADE: START THE MACHINE:\n")
                TD.enter_half_cycle(sym, dir, size, strategy_name)
            if dir == "UP":
                print("dude")

    if type == "small":
        current_trade = DB.get_current_trade(sym)
        if current_trade != None: #if a trade is open
            step = current_trade['step']
            if step >= 2:
                cur_dir = current_trade['dir']
                if cur_dir != dir: #
                    if current_trade['halving'] == 0:
                        TD.halving_event(sym, size, strategy_name)

def update_depth(sym, id, depth):
    """"""

# def enter_half_cycle(sym, dir, strategy_name):
#     ""
#     # enter first position, get it's db id, update its depth when other positions get filled
#     # hedging would probably rely on information from looking and analyzing past trade drawdowns in relation to itself, surroundings and outside forces
#     # hedging - like an insurance or like an opportunistic trade? which approach?
#     # as hedging in this case looks at the opposite direction,
#     # #is our trade and our current position an insurance or an opportunity?
#     if strategy_name == ST.minus_step:
#         if dir == "buy":
#             mq.close_all(sym, strategy_name)
#             DB.register_closed(sym, ST.BUY, strategy_name)
#             mq.order_buy(sym, ST.BUY, strategy_name)
#             DB.register_opened_without_listening(sym, "buy", strategy_name)
#         elif dir == "sell":
#             mq.close_all(sym, strategy_name)
#             DB.register_closed(sym, ST.BUY, strategy_name)
#             mq.order_buy(sym, ST.BUY, strategy_name)
#             DB.register_opened_without_listening(sym, ST.BUY, strategy_name)

# def halving_event(sym, size, strategy_type):
#     # if DB.check_halving(sym) == 0:
#     if strategy_type == "minus_step_one_buy":
#         mq.order_buy(sym, size, half_id)
#         mq.order_sell(sym, size/4, half_id)
#         mq.order_close_by_magic(sym, quater_id)
#         DB.record_halving(sym)




# def close_first_step(dir, sym):
#     """"""
# def close_second_step(dir, sym):
#     """"""

# def shift_stoploss(dir, sym, step, entry_price):
#     """
#     calculations for shifting stop loss
#     """


# def update_position(dir, sym, step, entry_price):
#     if step == 0:
#         close_first_step(dir, sym)
#     if step == 1:
#         close_second_step(dir, sym)
#     else:
#         shift_stoploss(dir, sym, step, entry_price)
#     DB.update_step(sym,dir)


# def order_close_by_magic(sym, magic_wanted):
#     all_positions = mt5.positions_get(symbol=sym)
#     if all_positions==None:
#         """"""
#     elif len(all_positions)>0:
#         df=pd.DataFrame(list(all_positions),columns=all_positions[0]._asdict().keys())
#         for _, row in df.iterrows():
#             if row['magic'] == magic_wanted:
#                 if row['type'] == 0:
#                     close(sym, row['volume'], magic_wanted, mt5.ORDER_TYPE_SELL_LIMIT,row['ticket'], mt5.symbol_info_tick(sym).bid)
#                 else:
#                     close(sym, row['volume'], magic_wanted, mt5.ORDER_TYPE_BUY_LIMIT,row['ticket'], mt5.symbol_info_tick(sym).ask)



# def edit_trade(id):
#     post = get_current_trade(id)
#     if request.method == 'POST':
#         title = request.form['title']
#         content = request.form['content']
#         if not title:
#             flash('Title is required!')
#         elif not content:
#             flash('Content is required!')
#         else:
#             conn = get_db_connection()
#             conn.execute('UPDATE {posts} SET title = ?, content = ?'
#                          ' WHERE id = ?',
#                          (title, content, id))
#             conn.commit()
#             conn.close()
#             return redirect(url_for('index'))
#     return render_template('edit.html', post=post)


def order_buy(symbol, strategy_name):
    return open_position(symbol, "BUY", strategy_name)

    # lot = calculate_lot(strategy_name)
    # if lot == None:
    #     return False
    # magic_number = ST.magic_numbers[strategy_name]

    # symbol_info = mt5.symbol_info(symbol)
    # if symbol_info is None:
    #     print(symbol, "order_buy: not found, can not call order_check()")
    #     mt5.shutdown()
    #     return False
    
    # if not symbol_info.visible:
    #     print(symbol, "order_buy: is not visible, trying to switch on")
    #     if not mt5.symbol_select(symbol,True):
    #         print("order_buy: symbol_select({}}) failed, exit",symbol)
    #         mt5.shutdown()
    #         return False
    
    # price = mt5.symbol_info_tick(symbol).ask
    # deviation = 20
    # """
    # !caution: actually removed stop loss and take profit
    #     "sl": price - 100 * point,
    #     "tp": price + 100 * point,
    # """
    # request = {
    #     "action": mt5.TRADE_ACTION_PENDING,
    #     "symbol": symbol,
    #     "volume": lot,
    #     "type": mt5.ORDER_TYPE_BUY_LIMIT,
    #     "price": price,
    #     "deviation": deviation,
    #     "magic": magic_number,
    #     "comment": "python buy",
    #     "type_time": mt5.ORDER_TIME_GTC,
    #     "type_filling": mt5.ORDER_FILLING_RETURN,
    # }
    # result = mt5.order_send(request)
    # print("order_buy: 1. order_send(): by {} {} lots at {} with deviation={} points".format(symbol,lot,price,deviation));
    # if result != None: 
    #     if result.retcode != mt5.TRADE_RETCODE_DONE:
    #         if result.retcode == 10027:
    #             UT.critical_error("Autotrading disabled")
    #         print("order_buy: order_send failed, retcode={}".format(result.retcode))
    #         return False
    #         # request the result as a dictionary and display it element by element
    #     else: 
    #         return True
    # return False

def order_sell(symbol, strategy_name):
    return open_position(symbol, "SELL", strategy_name)
    # lot = calculate_lot(strategy_name)
    # magic_number = ST.magic_numbers[strategy_name]

    # symbol_info = mt5.symbol_info(symbol)
    # if symbol_info is None:
    #     print(symbol, "order_sell: not found, can not call order_check()")
    #     mt5.shutdown()
    #     return False

    
    # if not symbol_info.visible:
    #     print(symbol, "order_sell: is not visible, trying to switch on")
    #     if not mt5.symbol_select(symbol,True):
    #         print("order_sell: symbol_select({}}) failed, exit",symbol)
    #         mt5.shutdown()
    #         return False
    
    # # point = mt5.symbol_info(symbol).point
    # price = mt5.symbol_info_tick(symbol).bid
    # deviation = 20
    # """
    # !caution: actually removed stop loss and take profit
    #     "sl": price - 100 * point,
    #     "tp": price + 100 * point,
    # """
    # request = {
    #     "action": mt5.TRADE_ACTION_PENDING,
    #     "symbol": symbol,
    #     "volume": lot,
    #     "type": mt5.ORDER_TYPE_SELL_LIMIT,
    #     "price": price,
    #     "deviation": deviation,
    #     "magic": magic_number,
    #     "comment": "python sell",
    #     "type_time": mt5.ORDER_TIME_GTC,
    #     "type_filling": mt5.ORDER_FILLING_RETURN,
    # }
    
    # result = mt5.order_send(request)
    # print("order_to_sell: 1. order_sell(): by {} {} lots at {} with deviation={} points".format(symbol,lot,price,deviation));
    # if result != None: 
    #     if result.retcode != mt5.TRADE_RETCODE_DONE:
    #         if result.retcode == 10027:
    #             UT.critical_error("Autotrading disabled")
    #         print("order_sell: order_send failed, retcode={}".format(result.retcode))
    #         return False
    #         # request the result as a dictionary and display it element by element
    #     else: 
    #         return True
    # return False

# def close_all(sym, strategy_name):
#     check_closed = []
#     magic_number = ST.magic_numbers[strategy_name]

#     all_positions = mt5.positions_get(symbol=sym)
#     if all_positions==None:
#         print("no current position")
#     elif len(all_positions)>0:
#         df=pd.DataFrame(list(all_positions),columns=all_positions[0]._asdict().keys())
#         for _, row in df.iterrows():
#             if row['magic'] == magic_number:
#                 if sym == "":
#                     sym=row['symbol']
#                 if row['type'] == 0: #current a short, buy to close.
#                    r =  close_request(row['type'], row['volume'], magic_number, mt5.ORDER_TYPE_BUY_LIMIT, row['ticket'], mt5.symbol_info_tick(sym).ask)
#                 if row['type'] == 1:  #long, sell to close
#                    r = close_request(sym, row['volume'], magic_number, mt5.ORDER_TYPE_SELL_LIMIT, row['ticket'], mt5.symbol_info_tick(sym).bid)
#                 result =  mt5.order_send(close_request)
#                 for _ in range(5):
#                     if result != None: 
#                         if result.retcode != mt5.TRADE_RETCODE_DONE:
#                             result =  mt5.order_send(close_request)
#                         else: 
#                             print("closed")
#                             break
#                     else:
#                         result =  mt5.order_send(close_request)
                
# def close_request(sym, volume,magic_wanted, order_type, ticket, price):
#     """"""
#     close_request={
#         "action": mt5.TRADE_ACTION_CLOSE_BY,
#         "symbol": sym,
#         "volume": volume,
#         "type": order_type,
#         "position": ticket,
#         "price": price,
#         "deviation": 20,
#         "magic": magic_wanted,
#         "comment": "python close",
#         "type_time": mt5.ORDER_TIME_GTC, # good till cancelled
#         "type_filling": mt5.ORDER_FILLING_RETURN,
#     }
#     return close_request