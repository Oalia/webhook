# @app.route('/webhook', methods=['POST'])
# def webhook():
#     if request.method == 'POST':
#         print("hello webhook")
#         webhook_msg = json.loads(request.data)
#         # ticker = webhook_msg['ticker']
#         # time = webhook_msg['time']
#         # volume = webhook_msg['bar']['volume']
#         print(webhook_msg)
#         return 'success', 200
#     else:
#         abort(400)


def strategy_minus_step_one_buy(sym,dir,size,type):
    strategy_name = "minus_step_one_buy"
    if type == "big":
        current_trade = DB.get_current_trade(sym, strategy_name)
        if current_trade != None: #if a trade is open
            if current_trade['is_trade_closed'] == 0: 
                cur_dir = current_trade['dir']
                if cur_dir != dir: # if trade direction has changed.
                    print("TRYING TO CLOSE HALF CYCLE:\n")
                    TD.close_half_cycle(sym, dir, strategy_name)
                else:
                    print("ABOUT TO STEP FORWARD: WEAR YOUR SEATBELTS\n")
                    DB.update_step(sym, dir)
            elif current_trade['is_trade_closed'] == 1: 
                if dir == "DN":
                    print("NO OPEN TRADES ON KNOWN SYMBOL. ENTERING.\n")
                    TD.enter_half_cycle(sym, dir, size, strategy_name)
        else:
            if dir == "DN":
                print("NO CURRENT TRADE: START THE MACHINE:\n")
                TD.enter_half_cycle(sym, dir, size, strategy_name)
            if dir == "UP":
                print("dude")

    if type == "small":
        current_trade = DB.get_current_trade(sym)
        if current_trade != None: #if a trade is open
            step = current_trade['step']
            if step >= 2:
                cur_dir = current_trade['dir']
                if cur_dir != dir: #
                    if current_trade['halving'] == 0:
                        TD.halving_event(sym, size, strategy_name)

def update_depth(sym, id, depth):
    """"""

# def enter_half_cycle(sym, dir, strategy_name):
#     ""
#     # enter first position, get it's db id, update its depth when other positions get filled
#     # hedging would probably rely on information from looking and analyzing past trade drawdowns in relation to itself, surroundings and outside forces
#     # hedging - like an insurance or like an opportunistic trade? which approach?
#     # as hedging in this case looks at the opposite direction,
#     # #is our trade and our current position an insurance or an opportunity?
#     if strategy_name == ST.minus_step:
#         if dir == "buy":
#             mq.close_all(sym, strategy_name)
#             DB.register_closed(sym, ST.BUY, strategy_name)
#             mq.order_buy(sym, ST.BUY, strategy_name)
#             DB.register_opened_without_listening(sym, "buy", strategy_name)
#         elif dir == "sell":
#             mq.close_all(sym, strategy_name)
#             DB.register_closed(sym, ST.BUY, strategy_name)
#             mq.order_buy(sym, ST.BUY, strategy_name)
#             DB.register_opened_without_listening(sym, ST.BUY, strategy_name)

# def halving_event(sym, size, strategy_type):
#     # if DB.check_halving(sym) == 0:
#     if strategy_type == "minus_step_one_buy":
#         mq.order_buy(sym, size, half_id)
#         mq.order_sell(sym, size/4, half_id)
#         mq.order_close_by_magic(sym, quater_id)
#         DB.record_halving(sym)




# def close_first_step(dir, sym):
#     """"""
# def close_second_step(dir, sym):
#     """"""

# def shift_stoploss(dir, sym, step, entry_price):
#     """
#     calculations for shifting stop loss
#     """


# def update_position(dir, sym, step, entry_price):
#     if step == 0:
#         close_first_step(dir, sym)
#     if step == 1:
#         close_second_step(dir, sym)
#     else:
#         shift_stoploss(dir, sym, step, entry_price)
#     DB.update_step(sym,dir)


# def order_close_by_magic(sym, magic_wanted):
#     all_positions = mt5.positions_get(symbol=sym)
#     if all_positions==None:
#         """"""
#     elif len(all_positions)>0:
#         df=pd.DataFrame(list(all_positions),columns=all_positions[0]._asdict().keys())
#         for _, row in df.iterrows():
#             if row['magic'] == magic_wanted:
#                 if row['type'] == 0:
#                     close(sym, row['volume'], magic_wanted, mt5.ORDER_TYPE_SELL_LIMIT,row['ticket'], mt5.symbol_info_tick(sym).bid)
#                 else:
#                     close(sym, row['volume'], magic_wanted, mt5.ORDER_TYPE_BUY_LIMIT,row['ticket'], mt5.symbol_info_tick(sym).ask)



# def edit_trade(id):
#     post = get_current_trade(id)
#     if request.method == 'POST':
#         title = request.form['title']
#         content = request.form['content']
#         if not title:
#             flash('Title is required!')
#         elif not content:
#             flash('Content is required!')
#         else:
#             conn = get_db_connection()
#             conn.execute('UPDATE {posts} SET title = ?, content = ?'
#                          ' WHERE id = ?',
#                          (title, content, id))
#             conn.commit()
#             conn.close()
#             return redirect(url_for('index'))
#     return render_template('edit.html', post=post)